package handlers

import (
	"database/sql"
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/trading-system/go-api/internal/database"
)

type ReportHandler struct {
	db *sql.DB
}

func NewReportHandler() *ReportHandler {
	return &ReportHandler{
		db: database.DB,
	}
}

// GetReport handles GET /api/v1/report/:symbol
func (h *ReportHandler) GetReport(c *gin.Context) {
	symbol := c.Param("symbol")

	query := `
		SELECT generated_content, report_id, timestamp
		FROM llm_generated_reports
		WHERE stock_symbol = ? AND report_type = 'stock_analysis'
		ORDER BY timestamp DESC
		LIMIT 1
	`

	var content string
	var reportID string
	var timestamp string
	err := h.db.QueryRow(query, symbol).Scan(&content, &reportID, &timestamp)
	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			"symbol": symbol,
			"data_available": false,
			"message": "No report available. Report will be generated during batch processing.",
		})
		return
	}

	var report map[string]interface{}
	if err := json.Unmarshal([]byte(content), &report); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse report"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"report_id": reportID,
		"symbol": symbol,
		"timestamp": timestamp,
		"report": report,
	})
}

// GenerateReport handles POST /api/v1/report/:symbol/generate
// This endpoint triggers report generation (async via Python worker)
func (h *ReportHandler) GenerateReport(c *gin.Context) {
	symbol := c.Param("symbol")
	
	// Note: In a production system, this would trigger the Python worker
	// via a queue (Redis) or direct API call. For now, we return instructions.
	
	c.JSON(http.StatusOK, gin.H{
		"message": "Report generation triggered",
		"symbol": symbol,
		"note": "Report will be generated by Python worker. Use GET /api/v1/report/:symbol to retrieve it after generation.",
		"status": "queued",
	})
}

// ListReports handles GET /api/v1/reports
func (h *ReportHandler) ListReports(c *gin.Context) {
	limit := c.DefaultQuery("limit", "50")
	
	query := `
		SELECT report_id, stock_symbol, timestamp, report_type
		FROM llm_generated_reports
		WHERE report_type = 'stock_analysis'
		ORDER BY timestamp DESC
		LIMIT ?
	`

	rows, err := h.db.Query(query, limit)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	defer rows.Close()

	var reports []map[string]interface{}
	for rows.Next() {
		var reportID, symbol, timestamp, reportType string
		if err := rows.Scan(&reportID, &symbol, &timestamp, &reportType); err != nil {
			continue
		}
		reports = append(reports, map[string]interface{}{
			"report_id": reportID,
			"symbol": symbol,
			"timestamp": timestamp,
			"report_type": reportType,
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"reports": reports,
		"count": len(reports),
	})
}
